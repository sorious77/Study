## Array

- 특징
  - <index, value>의 한 쌍으로 이루어진 자료 구조
  - 같은 데이터 타입의 자료를 가진 선형 구조로, 연속된 메모리 공간에 데이터를 저장
  - 삽입된 순서대로 저장, 데이터의 수정 가능
  - 순차적으로 데이터를 저장하기 때문에, 중간에 있는 데이터를 삭제한 경우에는 그 뒤의 데이터를 모두 이동해야 함
  - 미리 할당한 배열의 크기를 벗어나 재할당하는 경우 리소스의 사용이 커짐
  - 배열 내에 배열을 선언 가능

- 시간 복잡도
  - 삽입/삭제(정렬이 된 배열의 경우)
    - 배열의 맨 앞/중간에 삽입/삭제하는 경우 : O(n)
    - 배열의 맨 뒤에 삽입/삭제하는 경우 : O(1)
  - 탐색
    - O(1)
- 장점
  - index만 알고 있으면 해당 데이터에 접근이 가능
  - 연속된 메모리 공간을 사용하기 때문에 관리가 편함
- 단점
  - 삽입/삭제가 오래걸림
  - 배열의 크기를 바꿀 수 없음
    - 재할당을 통해 기존 배열의 값을 복사해야 함 -> 오버헤드 발생
  - 공간의 낭비 발생 가능
    - 실제 사용하는 공간에 비해 크게 공간을 할당하면, 공간의 낭비가 발생

- 활용
  - 순차적인 데이터를 저장할 때
  - 데이터의 개수가 정해져 있을 때
  - 빠른 검색이 필요할 때
  - 삽입/삭제가 자주 이루어지지 않을 때



## In C++

- 동적, 정적 할당이 모두 가능

  ```c++
  int a[5]; // 정적 할당
  
  int *b = new int[5]; // 동적 할당
  
  int **c = new int[5]; // 이차원 배열의 동적 할당
  for(int i=0;i<5;i++){
      c[i] = new int[5];
  }
  ```

- 함수의 파라미터로 사용하는 경우, Pass By Reference 타입으로 전달

  ```c++
  int change(int *a){
      a[1] = 9999;
  }
  
  int main(){
      int a[3] = {1,2,3};
      
      printf("%d %d %d", a[0], a[1], a[2]); // 1 2 3 출력
      
      change(a);
      
      printf("%d %d %d", a[0], a[1], a[2]); // 1 9999 3 출력
      
      return 0;
  }
  ```



## Practice

- 배열의 합 : [LINK](https://www.acmicpc.net/problem/2167)
- 분수 찾기 : [LINK](https://www.acmicpc.net/problem/1193)